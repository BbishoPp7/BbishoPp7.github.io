{"meta":{"title":"BbishoPp","subtitle":"","description":"","author":"BbishoPp","url":"http://example.com","root":"/"},"pages":[{"title":"categories","text":"","path":"categories/index.html"},{"title":"about-me","text":"","path":"about-me/index.html"},{"title":"tags","text":"","path":"tags/index.html"}],"posts":[{"title":"测试覆盖率笔记","text":"Criteria-Based Test Design[toc] 一 新旧测试观念 旧的测试观念 旧的观点把重点放在每个软件开发阶段的测试上 因为它与其他阶段非常不同单元，例如模块，集成，系统… 新的测试观念 侧重结构和标准方面 输入空间 图 逻辑表达式 语法 每个阶段的测试设计基本相同 创建模型是不同的 选择值和自动化测试是不同的 二 测试覆盖率标准（Test Coverage Criteria） Test Requirements: 测试用例必须满足或覆盖的软件的特定元素 Coverage Criterion: 对测试集施加测试要求的规则或规则集合 测试者的任务就是，建立针对测试软件的模型，寻找可以覆盖它的方法 三 覆盖（Coverage） 定义： 给定覆盖标准C的一组测试需求TR，测试集T满足C覆盖当且仅当对于TR中的每个测试需求tr，T中至少有一个测试t，使得t满足tr 不可行测试需求——无法满足的测试要求 不存在满足测试要求的测试用例值 示例：死代码 对于大多数测试标准来说，不可行测试需求的检测在形式上是不可判定的 因此，100%的覆盖率在实践中是不可能的 例子 给定两个覆盖准则： 口味覆盖：每种口味吃一个糖颜色覆盖：每种颜色吃一个糖 给定一个测试集T1 = { three Lemons, one Pistachio, two Cantaloupes, one Pear, one Tangerine, four Apricots } 1测试集T1满足口味覆盖么? 答案：满足，因为六种口味都测试到了 给定一个测试集T2 = { One Lemon, two Pistachios, one Pear, three Tangerines } 1测试集T2满足口味覆盖么? 答案：不满足 1测试集T2满足颜色覆盖么? 答案：满足 四 覆盖等级 T满足的测试要求的数量与TR大小的比率 测试集T2的口味覆盖等级为4/6 五 使用测试准则（Test Criteria）的两种方法 直接生成满足标准的测试值 通常由研究界承担 使用标准的最明显方式 没有自动化工具很难 从外部生成测试值，并根据标准进行评估 通常受到工业界的青睐 有时误导 Test Criteria有时被称为metrics 六 Generators and Recognizers 生成器：自动生成满足标准的值的过程 识别器：决定一组给定测试值是否满足标准的程序 对于大多数标准来说，这两个都是不可证明的 与生成满足标准的测试相比，识别测试用例是否满足标准的频率要高得多 七 标准包含（Subsumption） 定义 测试标准C1包含C2当且仅当满足标准C1的每组测试用例也满足C2 对于每一组测试用例都必须为真 例如上题： 糖的味道标准包含了颜色标准 如果我们品尝每种味道，我们就会品尝每种颜色中的一种 分支覆盖包含语句覆盖 如果一个测试集覆盖了程序中的每个分支（满足分支标准），那么该测试集就保证也覆盖了每个语句 八 良好覆盖标准的特点 自动计算测试需求应该相当容易 生成测试值应该是有效的 由此产生的测试应尽可能多地揭示故障 包含只是故障揭示能力的粗略近似值 九 覆盖标准的优点 标准最大限度地提高了“成本效益” 更少的测试更有效地发现故障 具有最小重叠的综合测试集 从软件工件到测试的可追溯性 来源、需求、设计模型… 回答每个测试的“为什么” 对回归测试的内置支持 测试的“停止规则”可以提前知道需要进行多少次测试 有利于自动操作 可以通过强大的工具得到很好的支持","path":"2022/03/11/测试覆盖率笔记/"}],"categories":[],"tags":[]}